Динамические структуры данных

Простейшая структорой данных является массив 
Массив -это набор перемееных в непрырывной области памяти
Приемуществом массива является быстрый доступ к элементам которой осуществляется за констатное время,по скольку сводится к оперции сложения а операция сложения всегда осуществляется за константное время 
Недостатка массива является сложноссть добавление,удаление массива,которая приводит к доролнительным затратам памяти и процесоороного времени  и зависит от размера массива
Неприрывная область памяти как раз обусловливает приемущество и не достатки массива
Недостатки массиво устраняют списки

Список(лист)-это множество элементов впроизвольной областях памяти,в каждой из которой содержит адресс следующего элемента
То что элементы списка находятся в произвольной боластях памяти,позволяют добавлять и удалять эти элементы без переопределение памяти 
Главным приемущество списка перед массива является быстрое добавление удаление и удаление элементов,которая остуществляется за констатное время и не зависит от размера
Потому что элемент не сравинительно можно можно распределить гд есть свободная память и для этого нам не нужно перреопределять весь список ,но главынм недостатком спискка является медленным доступ,который уже завист от размера списка
В отличии от массива,который дает произвольный доступ к элементам,список обеспечивает последовательный доступ к элементам и чтобы получить доступ к элементу нужно пройти через все элементы списка от его начала
Улюбого списка есть голова,у которого хранит адресс начального элемента списка,последний элемент списка всегда указывает на ноль
Реализация односвязного списка 
Односвязный список реализуется при помощи двух классов 
Класс элемент,описывает структуру элементов ,любой 
Data-значение элемента
pNext содержит одресс следующего элемента

LIST,Который отвечает объедение элементов в список,добавление,удаление элементов и тд

initializer_list-это контейнер 
Контейнер это объект,коорый организует храненин других объектов в памяти 
Как и любого друго контейнера по initializer_list есть методы begin () и end()
Begin()-возвращает итератор на начало контейнера
end()-Возвращает итератор на конец контейнера
cout<<typeID(il.Begon().name()<<endl;

Двухсвязный список
Это динамическая структура данных предстовляющая собой множество элементов в разных областя памяти ,кождая из которохы содержит адрес следующего и предыдущего элемента
	бЛАГОДОРЯ УКАЗАТЕЛЮ НА ПРЕДЫДУЩИЙ ЭЛЕМЕНТ ПО СПИСКУ МОЖНО ХОДИТЬ В ОБОИХ НАПРАВЛЕНИЯХ ОТ НАЧАЛА ДО КОНЦА И ОБРАТНО 
	У двухсвязного списка есть не только голова но и хвост т к голова указывает на начальный элемент списка,хвост указывает на последний элемент списка и когда список пуст 

	его голова и хвост указывают на ноль
	Когда в списке появляется первый элемент он одновременно является и головой и хвостом и также он является оновременно и первым и последним списком с какой стороны не посмотреть
Этолонный двухсвязный список 
Благодоря указателюб на последний элемент списка  а таке блоагодоя каждый элемент указан на не только наследующий но и на предыдующий По списку можно ходить в обохи направлениях 
Это позволяет сократитить время доступа к элементу списка в худшем случае два раза по сравнению с односвязным списком ,если элемнт ближе к началу списка то до него проще дойти через голову и если элемент ближе к концу списка то до него проще дойти через хвост
и таким образом в наихудшем случае мы доходим до серидины списка 
Двухсвязный список таже как и односвязный список реализются при помощи двух классов Elemen и лист

Бинарное дерево -это динамическая структура данных,каждая элемента которых имеет два потомка (левый и правый)
Левый потомок,содержит меньше чем в текущем элементе,а правый больше чем в текущем элементе
Главным приемуществом бинарного дерева перед остальными структурами давнных является то,что бинарное дерево дает самы быстрый доступ к элементам
В бинарном дереве из тысячи элементов нужное значение можно найти максимум за 10 шагов в 2(10 степени )
также как и любого другого дерева,у бинарного дерева есть корень (ROOT) и когда дерево пустое,его корень указывает на 0
Каждый жлемент в корне содерж значение и два указателя (pLeft-левая ветка(укозатель),pRight -правая ветка,указатель)
Элементы не имеющие потомков называются льстьями(Leafs)
В идеальном бинарм дереве в каждый узел на заданной глубине имеет одинакове колоичество потомков кпроме того колличество узлов на заданном глубине равно в степени 2 для этой глубины
На нулевой глубине находится корневой элемент

Кроме идеально сбалансировано бинарное дерево существует также выражденное бинарное дерево ,которая растест в одну сторону и по своим свойствам напоминает односвязный список
Существует две реализации бинарного дерева Рекурсивное и итерационное
В итерациооной реализации каждый элемент должен содеражть еще и адресс родительского элемента 
В рекурсивой реализацей такой небобходимости нет,по сколку аджресса радительских элементов сохраняется в стеке вызовов
